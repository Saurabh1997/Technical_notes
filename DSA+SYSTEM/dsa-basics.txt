------------------Basic maths-----------------
--to extract the digits of a number for e.g -  n = 8347 
	we can do while (n>0) {
					lastDigit = n%10 		// to extract last digit we can do modulus
					 n = n/10		// to remove last digit here
					}
		Now to count the number of digits,  we only need to do n=n/10. 
			can we say numberOfdigits = int(log10(number) + 1);
			

-------------------DSA---------------------
-ARRAY--
if array has a static size, it will allocate a heap memory at compile time only.. so runtime would be faster..
if dynamic, little performance may hit but not significant. 

-STRING--
if all characters are allowed, there are 256 ascii characters. 

--------EUCLEDEAN ALGORITHM---------- FOR GCD OF STRING AND NUMBERS. 
FOR TWO NUMBERS OR TWO STRINGS... A AND B, 
WE DO IF VALUE1 === 0 RETURN value 2 
and return GCD(value2%value1, value1)

we calculate value2 % value1 and assign it as A and assign value1 as B.. as we will be reducing value 1 in next loop to value2 % value1. 

------------PERMUTATIONS-----------------------------------
selecting data from a group of data is permutation.

example - if we have 3 letters A, B and C and have to FIND NUMBER OF WAYS TO PICK 2 letter to make unique permutations..  in a specific order.. 
ORDER OF ARRANGEMENT IS IMPORTANT... AB AND BA ARE DIFFERENT. 
so basically have to position r letters out of n letters in a distinct way.. how many number of ways 
nPr = n ! / (n-r)!

------------COMBINATIONS-----------------------------------
arranging the order is combinations. 
HERE , IF WE HAVE 3 LETTERS A,B AND C WE HAVE TO SELECT 2 LETTERS WHICH HAVE DIFFERENT COMBINATIONS...
CHANGING ORDER OF ARRANGEMENT MEANS THE SAME COMBINATION.. SO AB AND BA ARE SAME.. FOR SELECTING AB AND BA ARE SAME. 

nCr = n! / r!(n-r)!

latest rank - 4/11/2024 -- 3,060,211

latest Rank - 4/13/2024 -- 2,949,844

rank - 4/13/24 ----------- 2,848,768 --  2,851,079 - 2,853,261 -- 2,866,895

--------------GREEDY APPROACH-------------------------------
At every iteration, we have to make a choice which should be greedy in nature. 
IT FOLLOWS PROBLEM SOLVING APPROACH OF MAKING LOCALLY OPTIMAL CHOICE AT EACH STAGE WHILE hoping to FINDING THE GLOBAL OPTIMAL SOLUTION.  

Problems on which greedy solution works have 2 properties -
global optimum can be achieved by choosing local optimal  (greedy choice everytime)
optimal solution to the problem contains optimal solution to sub problems 


CON: very often don't provide a global optimum solution. it doesn't consider a choice once it finds a better choice which isn't a perfect but DP considers it which can be a bit exhaustive.

Example - 	Huffman coding, Job sequencing problem, fractional knapsack, prim's minimum spanning tree, activity selection. 


------------DYNAMIC PROGRAMMING--------------------------
Dynamic programming is an algorithmic approach which solves problem by dividing into smaller sub problems to solve each subproblem but it stores each subproblem to avoid solving same subproblem more than once.

DP is used for optimization, memoization.  

Problems which can be solved by DP need to have 2 props:
1. Optimal substructure - 
	A problem is said to have optimal substructure if optimal solution can be derived from optimal solutions of subproblems.
	
2. Overlapping subproblems -  
	A problem is said to have overlapping subproblems if by dividing the problems recursively into subproblems we are able to solve same subproblems more than once. 
	

Example - N steps to climb. find ways to climb.. can climb 1,2 ,3 steps at a time. 
	So we do reverse engineering.. we start from Nth step. 
		to calculate Nth step, ways(N) = way(n-1) + ways(n-2) + ways(n-3) 	
			Now to reach n-1, n-2, and n-3, we have 3 more ways... 
				way(n) = (way(n-1 - 1) + way(n-1 - 2) + way(n-1 - 3)) + way(n-2 -1) + way(n-2 -2) + way(n-2 - 3)
						way(n-2) + way(n - 3) + way(n - 4) + way(n - 3) + way(n - 4) + way(n-5).....
						Here we can use recursion.
						
					but we are calculating each way for e.g (n-3) more than once, so we will store this sub problem somewhere to avoid recalculating the same. 
					
	2 DP approaches - 
		1. Memoization - top down approach - it keeps same recursive approach but uses a lookup table to store the result of each subproblem so that we avoid solving the same subproblem. It breaks down a problem into smaller and smaller subproblems. Once we encounter the same subproblem, we will return same result from the lookup table, if we encounter a new subproblem, we calculate it.. and before returning it we store in the lookup table. 
		
		2. Tabulation - bottom up approach - it starts with smallest subproblem, It starts with smallest subproblem and then keeps solving bigger and bigger problems using computations of the previous smaller subproblems until we solve the actual larger problem. 