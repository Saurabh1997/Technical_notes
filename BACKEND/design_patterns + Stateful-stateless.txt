Design Patterns in NodeJS

1. Factory Method pattern - 
acts as a tool to clean up the code. centralize the logic of creating objects in a single place and then reuse whenever required. 

We define base class and entity classes which are reusing the same base class and a function inside the entity class will return that particular data. All objects will share same set of interfaces.

for example - 

	 let factory = new MyEmployeeFactory()
     employees.push(factory.createEmployee({type: "contractor"})    )}

class Employee {
speak(){
return "Hi" 
}}

class ContractEmployee extends Employee {
constructor(data){
super()
this.type = "contractor"
}}

class MyEmployeeFactory extends Employee {
createEmployee(data){
if(data.type === "contractor"){
return new ContractEmployee(data)
}}}

USECASE IN NODEJS - if we want to configure error messages, response messages in a single object, we can do using factory method. creating Errorfactory class and instantiating everytime we want to return error message.
if(err){
res.json(Errorfactory.getError(err))
}

2. Singleton pattern: this pattern is implemented by using a single static property where they store the instance once it exists (in most programming languages).
but in JS, we dont have access to static variable.

let instance = null

class SingletonClass {

    constructor() {
     this.value = Math.random(100)
    }

    printValue() {
     console.log(this.value)
    }

    static getInstance() {
     if(!instance) {
         instance = new SingletonClass()
     }

     return instance
    }
}

	module.exports = SingletonClass
And you could use it like this:
	const Singleton = require(“./singleton”)

	const obj = Singleton.getInstance()
	const obj2 = Singleton.getInstance()   


Observer Pattern - publisher - subscriber pattern,


------------------STATEFUL VS STATELESS PATTERN---------
Backend should always be stateless to make it as light weight as possible. We can use stateful backend (having in memory cache) but its not a good design practice. We can use firebase and not need a backend but we need certain restrictions on who can directly access DB. so we usually have a backend to connect to the DB to query. 
In Some scenarios, we need to make our backend stateful. For EXAMPLE - 
	1. For CMS type of sites where we need to fetch latest content. can implement in memory variable/cache.
	2. For a gaming App like chess.com, where we have to fetch and update each and every board game move. If used DB for storing this, while fetching game move and updating, there will be some latency issues. so we can implement an  object as :
		[
			Room1 : {
				person1moves : [],
				person2moves: []
			},
			Room2: {
				person1moves
			}
		]
	PROBLEM: WHAT IF OUR SERVER DIES, HOW TO FETCH THE LATEST BOARD GAME MOVES THEN. Can implement a caching mechanism microservice and call it to update in database as soon as we update the in memory variable. 
	Most Real time apps/games need stateful backend to mitigate latency issues. and for scalability, we can use redis cache. 
	
	Stickiness - In case of real time apps where 2 or more peers have to get connected, if we are using in memory variable, we would have to add some stickiness. Stickiness is to make sure 2 or more peers which are connected should be connected via same server to share the same in memory variable.. for example in a chess app, we would need both peers connected to same server so as to fetch and update the same in memory variable for board moves. 
	
	CAN ALSO USE REDUX IN BACKEND TO IMPLEMENT STATE MANAGEMENT. 
	
-----NAIVE WAY TO MAINTAIN STATEFUL PATTERN IN BACKEND---
	Create interface and initialize variable with that name and can export and use it anywhere
	
-----Slightly better approach-----
	Instead of directly exporting variable, we can implement some wrapper mechanism or a wrapper class and in that class, can implement wrapper methods to manipulate the variable - clearing, modifying, fetching.
	
	class GameManager {
		let games = [] 
		constructor (game) {
			this.games = games
		}
		clearGames () {
			games = []
		}
	}
	const gamesManager1 = new GameManager(["data1"])
	const gamesManager2 = new GameManager(["data1"])
	
	ISSUE in this approach :
		1. We can create multiple instances of the same class and it won't restrict developer from creating so and then there won't be consistency in the codebase as there are multiple instances of the same class in our codebase.
		No one should be allowed to create another instance of the class in our codebase. 
		2. If we want to remove or clear all instances/objects of that class, we would have to individually clear each instance which wouldn't be a proper approach. 
	Solution : Singleton Pattern
	
--- Lot of design patterns - Singleton pattern, factory pattern, Strategy pattern and adaptor pattern. 
	Mostly used pattern in NodeJS - Singleton pattern and strategy pattern 
	
---Singleton Pattern-----------------------------------
	We have to make only one Single instance of this class and restrict developers also to not make more than one instance. 
	-- In normal classes, attributes - variable, methods inside a class are associated with creation of objects
		If we create new objects of that class, then only we would be able to use attributes of that class. Also we have to restrict creating multiple instances of that class. 
	-- Singleton Pattern Implementation -
		-- To Restrict making new instances of the class, we make constructor as private. 
		-- we make static method to expose single instance of this class. 
		-- We make that variable single instance as static private. 
				---STATIC -- to define something as a single copy/global. It can only be accessed via class and no need to create new instances. We can create instances of the class inside that class only and expose it via function. can call this function outside anywhere by ClassName.getInstance()
		
		class GameManager {
			private games: Game[]
			private static Games: GameManager 	// As this variable is static and belongs to class and not object of the class. 
			private constructor() {
				this.games = []
			}
			
			static getInstance() = () => {
				if(GameManager.Games) {
					// If instances already exists, directly return it
					return GameManager.Games
				}else {
					GameManager.Games = new GameManager()
					return GameManager.Games
				}
			}
			
			const updateGames = () => {
			}
		}
			
		To use this instance now anywhere, can just do 
		const game = GameManager.getInstance()
			game.updateGames()
			
---Strategy Design Pattern--------------
	It allows behavior/strategy to be selected at runtime. If we have a payment mechanism, we will have a class PaymentStrategy in which we will have switchStrategy method which when passed a strategy name can interchange its mechanism for e.g Razorpay, stripe
	