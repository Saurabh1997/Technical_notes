npm init -y
npx tsc --init -- to bootstrap typescript into nodejs. // After doing this, specify rootDir - src and outDir - dist in tsconfig.json. 
npx tsc -b -- to compile typescript to js. 
npmrc - npm config files. 

With Azure artifacts - can publish and download npm packages from feeds and public registries. 
Create feed - allows user to store packages and control who access them. 
npm publish - to publish packages. 
npm i --save - to restore packages. 

2 .npmrc files - one in project folder and other in $HOME to store credentials. 

adobe experience platform debugger

npx downloads latest version of create-react-app templates everytime. 

For performance related.. latency 
This is done with a metrics collection tool like prometheus. You can set up prometheus to collect information about APIs total number of requests, latency, etc even information about the CPU utilisation, nodejs event loop and many more which can help you in debugging errors. You can even set up alerts to get a notification incase an API has more error rate or latency than usual. Combined with Grafana you can view this data in beautiful dashboards.

PM2 vs cluster - 

PM2 and cluster are both used to scale nodejs applications across multiple CPU cores. 
1. Management - PM2 provides process manager that provides  lot of features such as application health monitor, log output, restart failed processes. whereas cluster provides basic process management & load balancing.
2. Configuration - PM2 provides lot of configuration via json and js files.. to configure number of processes, usage, whereas cluster just provides basic api to configure worker processes.
3. PM2 is designed to work in production environments & provides 0 downtime deployments & restarts. 
4. PM2 can work with any nodejs application. and is more powerful process manager.  

WHENEVER THERE IS A SECURITY VULNERABILITY FOR NESTED DEPENDENCIES, WE MUST FIRST UPDATE TOP LEVEL DEPENDENCY AND THEN SHOULD LOOK FOR THE NESTED ONES. 

Middlewares in Nodejs - its used to do prechecks before hitting route handlers. can be used to modify request and response objects. can add functionality to application such as authentication, logging, and error handling. 

useAuthMiddleware = (req,res,next) => {} // call next() to call next functions - routing methods. 
app.use() - req.body can be an html, text, json as well. so we use express.json() to specify to parse the body in json format. 

Error Handling middleware - Special type of middleware used for error and exception handling. they are used at the end of the route handlers to debug and handle errors.
	One of the type of error handling middleware is Global catching. In global catching, we pass a callback function in app.use with 4 params - err, req,res, next 
	for e.g : app.use(function (err,req,res,next) => {
				res.status(411).json({msg: "Something wrong with inputs"})
					})
	
----------------------ZOD------------------------------
Typescript static schema validation library like joi. gives us a blueprint of what we want to have from the front end. 
For e.g , we do stringSchema = zod.String()
n then for checking we do 		stringSchema.parse() // if fails then ZodError else success: true.
				stringSchema.safeParse() // if fails success:false with error object else success: true.
	checkStringIncludes = zod.literal("INR").or("USD")
--For array of numbers - zod.array(zod.numbers()) 
--for objects - zod.object({
	email: zod.string().email(),
	password: zod.string().min(8)
})

--ZOD COERCION FOR PRIMITIVES -- coercion means to push someone to do something . 
if we don't have to check strict typing.. like 12 can be converted to string "12". 
	for example - zod.coerce.string()

---AUTHENTICATION ----
why not just store email and password in UI and send them whenever validating each and every api request? 
	we don't want to compromise the safety of password by sending each and every time. As password is stored in the backend we dont want to compromise the safety and it will be difficult to remove the password in db. 

1.Hashing - one way and can't be decrypted. passwords are hashed to store in db. 
Whenever client sends a password, backend converts password into a hash which is compared with hashed password stored in DB.
2.Encrypted - 2 way. video/image storing on fb.. is encrypted before getting stored. 
3. JWT - json web tokens - takes json as input. it creates a token for authenticating all future api calls. it hashes the payload into a single token. 

	jwt.verify(token, password_used_for_hashing) // verification can only be done using password stored at backend.
secret keys are stored in github secret, secret managers.	
4. LocalStorage - to store data locally.. it doesn't get removed even if we close the session or browser. we have to manually remove it.  

mongoose - 
const User = mongoose.model("Users", {name: string, email: string})  
const user = new User({name: "Saurabh"})
user.save().then()

-- IT'S A MYTH THAT WE CANNOT SEND PAYLOAD IN GET. CLIENT CAN SEND DATA IN PAYLOAD BUT IT DEPENDS ON THE WEB SERVER WHETHER TO EXTRACT IT OR NOT. 
	example - search query for elastic search uses payload in the get request. 
WE CAN SEND DATA IN GET REQUEST PAYLOAD, BUT WE SHOULDN'T.
Note: as per http1.1, RFC 7231 specs - it doesn't mention anything about this. 

As per documentation of RFC, payload within GET request has no defined semantics unlike POST request. 
while sending payload in a get payload might be rejected by existing implementations. 
Earlier versions of elastic search - we used to send complex json based search query in HTTP Get body.
THIS PRACTICE IS DISCOURAGED AS IT MIGHT BREAK SOME EXISTING IMPLEMENTATIONS. 


----------------------------OPEN API------------------------------------------------

With Open API, a consumer can understand & interact with a remote service with minimal implementations logic.
Open API spec file generation is easy in Rust/Golang but difficult in JS/python. 

packages : 
	swagger ui express - requires manual json changes
	tsoa - typescript check swagger.
	Hono zod open api - for hono apps. we write code to generate open api spec file in json and then serve it on a route. 
			We serve this route then in swagger to generate open api docs.
			
--Autogenerated clients -  Using open api spec file, generating a library which provides functions that anyone can use to call the apis. 
			this library will be doing actual implementation to call the api and return the response. 
		Now a simple nodejs client can call this libary method to fetch data. We shouldn't do this for a nodejs api to call itself. 
		NOTE: THIS IS SPECIFICALLY IF ANY THIRD PARTY SERVICE WANTS TO USE OR CALL OUR API. 
		
	Openapi-typescript-codegen: 
	1. Store the openAPI spec in a file (spec.json)
	2. npx openapi-typescript-codegen --input ./spec.json --output ./generated 
		output a folder which has generated library.
	3. it generates a client - nodejs library which can provide function to call the apis. 
	4. should create a fresh nodejs project which can use this generated nodejs library by copying this core library into the fresh nodejs project.
	const response = await DefaultService.getUser("1")
	
-------------IF JS IS SINGLE THREADED HOW IT IS ASYNCHRONOUS--------------------
In JS, we have Call stack, callback queue and web apis/offloaded tasks/db calls. 
IF IN A API HANDLERS -- If there is any DB call, it can be offloaded to another CPU and once we get the response from the DB, it is put in callback queue. 
	IF more requests come, it is offloaded to another thing to do its process and then the response is put into callback queue. When the thread is free, it is put into call stack to execute/finish the task. THIS OFFLOADING HAPPENS IN ANOTHER THREAD. 
		main work done by JS is STILL SINGLE THREADED.

--------------EVENT LOOP IN NODEJS------------------------------
	JS is synchronous, blocking, single-threaded by default. To make async programming possible, it uses libuv. 
	---Code execution in nodejs - 
		We have v8 engine where our JS code will execute and libuv where async methods calling will execute. In V8 engine, we have 2 things - heap and call stack. whatever variable declaration is ther, it will be put into HEAP and whatever methods we are calling will go to call stack (Last in First out). LIBUV USES NATIVE ASYNC METHODS OF OS TO EXECUTE ASYNC METHODS.. if not available it will use thread from its thread pool to not block the main thread. 
	EVENT LOOP ORCHESTRATES THE EXECUTION OF SYNCHRONOUS AND ASYNCHRONOUS CODE IN NODEJS.
	
	Event Loop in nodejs in every iteration of the loop we come across 6 different queues - 
		1. timer queue. // associated with SetTimeout, interval
		2. I/O queue // http calls, fileread calls
		3. checkqueue // setImmediate calls
		4. close queue // handle closing the the callbacks - this 4 are part of LIBUV in nodejs
		microtask queues -- 5. nextTick queue // process.nextTick callbacks
							6. Promise queue // for promise callbacks. 
	
---Execution order ----
	1. Any callback functions in microtask queues is executed - first nextTick queue and then promise queue callbacks. 
	2. All callbacks in timer will be executed. then again step 1.
	3. All callbacks in I/O will be executed. then again step 1 if there are any callbacks in microtask.
	4. All callbacks in checkqueue and then step 1.
	5. All callbacks in close queue and then step 1. 

	
	NOTE: ALWAYS USER WRITTEN SYNCHRONOUS JS CODE WILL TAKE PRIORITY OVER ASYNC CODE AND ONCE CALL STACK IS EMPTY EVENT LOOP WILL COME INTO PICTURE. 
		
-----ASYNCHRONOUS MEANS NOT OCURRING AT THE SAME TIME----
	Sometimes we may need to do execute some functions with a delay.. which might take time but we can't block execution of other sequential tasks. For example we want to call an api which might take time. 
		we classify asynchronous js operations with 2 primary : 
			1. Browser/web api API, event handlers like onclick, onmouseover. 
			2. Promises - js object to perform asynchronous operations.
	Async functions are pushed onto the libuv or other thread to execute it there. 