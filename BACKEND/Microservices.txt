Monolith contains routing, middlewares, business logic, DB access to implement all features of the app.
A single microservice contains all this routing, middleware, business logic, DB access to implement one feature of our app. 
services are self-contained. 

Data management between microservices is difficult. 

note: SERVICES WILL NEVER REACH INTO ANOTHER SERVICE'S DATABASE. every service gets its own database. 
we want each service to run independently of other services. 
Some services might function more efficiently with diff. types of DBs.  it will be easier to scale any DB which requires additional throughput. 

sync between communication services - 
two communication strategies -- sync and async 

1. Sync - services communicate with each other using direct requests.. not api calls.
for example, service to show products ordered by user will make 3 requests -- 
1. service to filter orders by user id. code to get user details of products ordered will return list of order ids. 
2. from order ids,  service to list product details by order id. 

			CONS: but this service will be depending on other service. can be slower. can introduce web of dependencies.. or requests. 

Async - 
services communicate with each other using events.

Two approaches 

1. Event bus 
Event Bus - accessible throughout the entire application. handle little notifications or events being emitted by services. each service is connected to event bus. each service either subscribes(receive events) or publish(emit events) the events.

Service D which wants products ordered by a user -- will emit event -- type of event and data associated with it (type : userQuery, data: userID)
Service A subscribes to the event (UserQuery -- will get userID from the event bus and then pass the information by emitting event with UserQueryResults )
Service D will be subscribing to event UserQueryResults and will get the results. 

2. Following DATABASE per service pattern - 
fix the exact goal of the service D. 
create a database with two seperate collections of data. one would be record of users signed.. list of all users. just order ids.. and user ids.
not entire combination of data.

Combine first strategy with the second to maintain this DB. anytime a user is created or user orders something it will update in a database and emit events to the event bus.. the microservice listening/subscribing to that event will put the new info in his own DB. 

pros & cons for the combined strategy. 
 pros - service D has 0 dependencies. it will be extremely fast compared to all the approaches. 
 
 cons - Data duplication. high storage. paying for high extra storage isn't a con. harder to understand. 

 API gateway - server that acts as single point of entry for set of microservices. it receives client requestsm forwards them to appropriate microservice and then returns the server's response to the client. Routing, authentication, rate limiting. can cache responses from microservices. reducing number of requests that needs to be forwarded to microservices. 
 

SSO - single sign on - built on a federal identity. sharing of identity across trusted systems
	2 common protocols for this authentication process - 
		1. SAML -  Security assertion markup language. it uses xml based standard for exchanging info between services. usually found in work environment.(office,zoom)
		2. OpenId connect - uses JWT to share identity across systems.  
	
DockerFile  - can create .dockerignore and put node_modules in it just like we do in .gitignore.. to ignore node_modules folder while copying to docker container. 
docker build -t tagName - to tag our docker image/container
docker run tagName
docker run -it , docker ps, docker logs container id

kubectl get pods, kubectl exec -ti podname sh - to run command inside the pod, 
kubectl delete pod podname,  kubectl apply -f filename, kubectl logs podname, kubectl describe pod podname


Kubernetes - 
	We create docker images of nodejs apis and push them to docker registry and then those images are fetched from registry to run as containers inside pods. 
	We deploy them into kubernetes Cluster. Cluster can have multiple nodes. 
	
K8s cluster = collection of nodes & master to manage them.
NODES - node is just a vm can run multiple containers. 

		To create containers to run in kubernetes, We create config file for kubernetes.. number of instance, networking.. we feed this config file to kubernetes using kubectl apply -f .
it will create containers and distribute them amongst nodes in cluster. each coontainer would running inside PODS.
PODS - smallest unit of kubernetes in which a container runs. pod wraps a container. pod can run multiple containers. 

DEPLOYMENTS - to manage kub8 pods, we create a deployment. it manages all those pods..recreating pods if any pod fails. 

SERVICES - to access other services inside a kubernetes cluster.. for e.g an oracle DB. it allows access to running pod inside of a cluster.  
				it gives a URL to access other kubernetes containers. 
				
				



	
		
	
	