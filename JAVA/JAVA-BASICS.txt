------------------------HOW JAVA WORKS---------------------
jAVA CODE IS COMPILED INTO BYTE CODE (HAVING .CLASS EXTENSION) USING JAVA COMPILER... AND JVM LOOKS FOR BYTE CODE TO EXECUTE.. IT WILL FIRST LOOK FOR MAIN FUNCTION TO EXECUTE. 
Java is platform independent as this byte code can be executed on any platform. 
JRE java runtime environment which wraps JVM and is responsible to running java code. will check byte code of all files, load classes and will run them on JVM. 
			
there's a big box - JDK. 
inside JDK we have JRE - java runtime environment and then inside JRE, we have JVM.  
JVM makes java platform indepedent. 

-----------------------MEMORY---------------------------
Inside JVM, we have memory. 
1. Stack - LIFO - last in first out. local variables and methods are part of stack.  
2. Heap - we store objects. Instance variable and object (reference variable) are part of heap. 
	Calculator classObj = new Calculator; // this is inside main()
	so here classObj will be in stack and will have reference to address. 
	Heap will have address of that reference variable n in that address will have properties(instance variable  n methods) of that class.  
NOTE: STACK IS CONNECTED TO HEAP VIA THE ADDRESS THAT THE REFERENCE VARIABLE POINTS TO. 


Memory in application is called heap memory managed by JVM.  JVM calls out a subroutine (system.gc) to delete all the objects which it can't reach out from the main stack. 
Whenever an object is created, entry is made in the heap and if we assign it as null after use, then it becomes eligible for garbage collection. 

---System.out.println--------
System - predefined class in java which is part of java.lang package which provides standard input, output and error streams of the system. 
out - public static field in systems class. represents output stream connected to terminal window.
println - method of PrintStream Class which type of out field. 

---------literals-----------
literals are source represenations of fixed values. used to repesent constant values in code. 

--------------ENCAPULATION------------
binding the data(attributes or fields) and methods (functions or behaviors) that operate on the data into a single unit.
basically we mark the variables inside a class as private so that it won't be accessible to anyone.  

------------------------STATIC KEYWORD---------------------static is a single copy stored in static memory which belongs to the class. 
ITS A SINGLE COPY OF VALUE FOR ALL THE OBJECTS. EVERY OBJECT WILL HAVE SAME VALUE.  (FOR VARIABLES)
a class cannot be static unless its an inner class. static class can only contain static methods, static variables and nested classes. 
STATIC METHOD  is a part of class rather instance of that class. we can directly called using className.staticMethodName()
				it can directly access static variables using className. ONLY STATIC DATA CAN BE ACCESSED USING STATIC METHOD. STATIC METHODS CAN BE ACCESSED IN BOTH NON STATIC AND STATIC METHODS. 				
		CAN REDECLARE SAME STATIC METHODS WHILE INHERITING, ITS NOT OVERRIDING, ITS CALLED REDECLARING - shadowing of the class functions. 
	NOTE: TO BE ABLE TO ACCESS NON STATIC VARIABLES IN STATIC METHOD, 
		WE CAN HAVE ARGUMENT AS CLASS OBJECT IN STATIC METHOD AND WHILE CALLING THIS METHOD PASS THE OBJECT REFERENCE VARIABLE. 
	
STATIC VARIABLES - local variable cannot be static. only global/instance variable can be static. 
			can be accessed using class, directly or using object. 

STACK BELONGS TO METHOD, HEAP BELONGS TO OBJECTS WHILE EVERY METHODS HAVE ITS OWN STACK. 

--static block :  will be initialized only once. 
	static {
	name = "Hello"     
	}

---STATIC BLOCKS ARE ALWAYS CALLED FIRST EVEN BEFORE CONSTRUCTOR AS STATIC BLOCKS BELONGS TO THE CLASS. FIRST THE CLASS IS LOADED AND THEN THE OBJECT ARE INSTANTIATED. 
NOTE: IF WE DON'T INSTANTIATE THE OBJECT, THEN STATIC BLOCK WON'T BE CALLED.. TO LOAD THE CLASS MANUALLY WITHOUT INSTANTIATING, 
WE CAN DO : 	Class.forName("Mobile")

---NOTE: ALWAYS define variables in constructor to initialize them at the time of object creation

-----------------------ABSTRACT----------------------------------
ABSTRACT CLASSES CAN HAVE ABSTRACT METHODS AS WELL AS NON ABSTRACT METHODS. 

-----------------------INTERFACES-------------------------------
blueprint of a class. Interfaces can have abstract as well as normal non abstract methods..
cannot create object of interface but can reference interface with a object of class that implements it. 
A CLASS CAN EXTEND ANOTHER CLASS AND IMPLEMENT ONE OR MORE INTERFACES. 
a CLASS IMPLEMENTING AN INTERFACE MUST BE PUBLIC. BY DEFAULT METHODS IN INTERFACE ARE ABSTRACT AND PUBLIC. 

----------------------WRAPPER CLASSES-------------------
	Data TYpes - primitives 
	Primitives - 4 types : 
		Integer - int, short, byte, long , Float- float, double , Character - char , Boolean - boolean 
WRAPPER CLASSES are used to encapsulate primitive data types.. such as byte (1 byte), short(2 byte), long(8 byte), int (Integer) (4 byte), float(4 byte), boolean 1bit,char (Character) (2 bytes), double(8 byte)..
	Integer - byte, short, int, long.
	float - double, float. 
	used to create objects of primitive data types. to convert from one data type to another. 
	ALSO USED IN COLLECTIONS. 
Conversion of primitive to Wrapper class is called AUTOBOXING. All wrapper classes are subclasses of Number Class. 	
1 byte = 8 bits so  for range - ( 2 raise to 7 ) - 1 
char should be in single quotes.    char x = 'a'

-----------------------Casting (explicit conversion) and Type conversion (implicit conversion)-----------
int a = 256 can't be converted directly into byte as its smaller. data loss is there. 
 so  b = (byte)a //  explicit - casting  while doing this it will apply 256 % 256 = 1 assign 1 
				256%256  as 127 + 127 (range of byte -127 to 127)
	a = b // byte can be directly converted into int as its bigger -- implicit conversion.   

-----------------------enhanced FOR EACH LOOP-------------------
for(int dat : data) {}  // for each loop

-------------------ARRAY -------------
	int x[] = {1,2,3} 
	int[] x = new int [5] // of length 5. // if we don't assign all elements they are initialized to 0.  
	int x[] = new int[3] {1,2,4}	
FOR 2D ARRAY , WE CAN HAVE DIFFERENT NUMBER OF ARRAY ELEMENTS.. FOR FIRST COLUMN, CAN HAVE 3 ELEMENTS. FOR SECOND , 2 ELEMENTS.
	int nums [][] = new int [4][]
		nums[0] = new int[2]
		nums[1] = new int[4]
		nums[2] = new int[5] // THIS IS KNOWN AS JAGGED ARRRAY. 
		
		NOW FOR TRAVERSING THROUGH THIS JAGGED ARRAY, 
			for(int i=0; i<nums.length;i++) {
					for(int j=0, j<nums[i].length;j++){}
			}
----------ARRAY OF OBJECTS------------------
	class Student {
	String name;
	int age;
	int rollno;
	}

	Student s1 = new Student()
	s1.name = , s1.age, // initialize all 
	Student s2 = new Student() // initialize all
	
	Student students[] = new Student[3]
	students[0] = s1;   students[1] = s2; students[2] = s3; // this will array of objects. 
	for(Student std: students){}
	
------------STRING---------------------
we have string constant Pool in heap.
	String name1 = "Saurabh"
	String name2 = "Saurabh" // THIS WILL CREATE A SINGLE OBJECT WHERE NAME2 WILL HAVE SAME REFERENCE AS OF name1. that's how java saves memory. 
Strings are immutable. 
	If we do :   name1 = name2 + "Patil" // it will create a new string object with new reference.. and not change the original one (maintaining its immutability).

-------------STRINGBUILDER AND STRINGBUFFER-----------------
BOTH ARE MUTABLE STRINGS. 
StringBuffer sb = new StringBuffer("Patil") // it assigns a buffer size of 16 bytes. 	
sb.append("saurabh") 

cannot convert stringbuffer to string but we will have to convert using tostring().
sb.deleteCharAt(1)
sb.insert(0, "Aps") // will add Aps at 0th index.

--NOTE: STRINGBUFFER IS THREAD SAFE AND STRINGBUILDER IS NOT. 
	stringBuffer methods are synchronized. only one thread can access it.  
	

----------------------EXCEPTION HANDLING-----------------java.lang
Throwable Class has 2 types - Error  and Exception.
Error - Assertion n stack over flow Error. (unchecked exception)
EXCEPTION -  IO exception, file not found - checked exception -- have to handle.  must write a catch block. 
		NullPointer ex, NumberFormat ex, Arithmetic ex, ArrayIndexOutOfBound ex. 
	NOTE: THERE SHOULDN'T BE ANY STATEMENT BETWEEN TRY AND CATCH N FINALLY BLOCK OTHERWISE CF. 
	IRRESPECTIVE OF THE TRY N CATCH BLOCK EXECUTED, FINALLY WILL GET EXECUTED. 
at compile time, see ref, at runtime see object.

NOTE: ALWAYS WARN OF EXCEPTIONS USING throws Exception.. Otherwise while compiling will get error as UNHANDLED EXCEPTION TYPE. 

to warn of exception :    void function_name() throws exception1, exception2 {
								}
		to throw exception - throw new Exception()	
		
	to make self defined exceptions, class Exception1 extends Exception {}
	
---------------------SUPER CLASS REFERENCE VARIABLE----------------
to call a super class version of a overriden method, we can use super.method(). // super - a non static method n can't be accessed from static method. 

-------------IS A RELATIONSHIP IS INHERITANCE.. HAS A RELATIONSHIP IS AGGREGATION----------------
				CLASS B EXTENDS A // A IS a B,  B is a A.
				Class X { A a}  // X has a A. 		
				
-------------------INNER CLASSES--------------------------
used to logically group classes for encapsulation.  for this compiler generates 2 class files  - outerClassFile.class and outer$innerCLassName.class
if inner class has same variable n method as of outer class, then outer class/variables go in hiding. 
1. Normal inner class:   
	to acess method inside of inner class. 
			A.B b = new A().new B(); 
			b.m1()
			//  or 
			new A().new B().m1()
			
2. static inner class. 
	as static can only access static.. but non static can access anything. 
	to access static inner class B, 
		new A.B().m1()
		or A.B b = new A().B()
3. Method local inner class:
	void m1() { // cannot declare this as static. 
	class B {
			
			}
		}
	to access, new A().m1()
---------------------------------Annonymous overrriding-------------------------
class A {
	void m1() {}
	}
class App {
	A a = new A() {
		void m1() {}
		void m2() {} 
		}
	a.m2() // CF won't allow. 	
	} 
---Anonymous overriding by Runnable interface--
	Inter i = new Inter() {
	public void m() {}
	}
	i.m();
	
------------------------------------------------------MULTITHREADING--------------------------------------------
thread is a light weight process in java which runs concurrently with other threads. Threads are independent of each other & can run simulaneously. 
-----Ways to do multi-threading : 
	1. Define a class which extends thread class and override a run() method and define your process. 
	When calling  A a = new A()
				a.start() // to start the thread.
	2. Creating Thread object directly:
		Thread t1 = new Thread(new A(), "name of thread") // A has also extended thread class and overrided run() method
		t1.start() // never override start method. 
	3. Implementing Runnable interface : 
		class A implements Runnable {
			public void run() {}
		}
		same way to start the thread t1.start()
	4. Overriding run by anonymously by runnable interface:
		Runnable r = new Runnable () {
		 public void main() {}
		}
		
		Thread t1 = new thread(r, "threadName") {
		public void run() {}
		}
	5. Annonymous Thread overriding : 
		Thread t1 = new Thread (new A(), "ThreadName") {
		public void run() {
			SOP(" B sb ")
			}
		}
	6. Complete annonymous:
		new Thread(new Runnable(){
			public void run(){
			
				}
			}, "threadName").start();
--------thread.sleep() // for pausing a thread. as soon as thread is paused.
--------t1.join() -- for sequencing thread. t1 will start after main thread. 
-------synchronizing threads--------------
	If 2 threads are sharing the same resource, there might be data inconsistencies between them. 
	2 ways to lock on that resource, synchronized methods and synchronized statements. 
	1. we can mark our method as synchronized.. it will put locks objects of its class by default. 
	2. Synchorization block : 
		Synchronized (ref/obj) {
			
			}
		need to pass reference to ensure synchronized behavior over that reference.	

----thread.wait() and .notify() -- used to prevent deadlocks.
	When a thread calls .wait, that thread will go to waiting state. then to call back the previous thread to resume, we do .notify(). 
	
-----------------COMPARATOR VS COMPARABLE---------------------
comparator is an interface in which we will have to implement compare method. 
WILL HAVE TO DO ANONYMOUS OVERRIDING OF COMPARE METHOD--

can also implement comparable 