TYPESCRIPT DEVELOPED BY MICROSOFT. js is the runtime language that runs in browser/node.. typescript only runs in browser and backend. 
typescript is something we compile into JS. 

npx tsc --init // to generate tsconfig.json file. 

tsc is the official typescript compiler used to convert typescript to js. FAMOUS COMPILERS/TRANSPILERS - 
1. esbuild.  2. swc. 

tsc -b - to compile into js. 

-- Basic types in typescript - null, undefined, string, number, boolean. 

---Assigning return type to function - 
	const funcSum = (name: string, age: number) : number => { return number }

---explicit and implicit assigning------------------------- 
let firstName: string = 'saurabh' // explicit - writing out the type

let firstName = "saurabh" // typescript will guess the type based on assigned value. 
Having typescript guess the type of a value is called infer. Implicit assignment forces typescript to infer. 

for explicit, it will throw error for mismatching. but for implicit, it won't throw error. 

-----------------TYPESCRIPT SPECIAL TYPES - 
any - disables type checking. but it won't provide any type checking. SHOULD BE AVOIDED AT ANY COST. 
unknown - similar to any but safer. it will prevent unknown types from being used. 
never - let x : never = true // throws error whenever it is defined. 

-----------------interface in typescript 

interface PersonInterface {
id : number,
name: string,
register() : string  // returns string 
}

class Person implements PersonInterface {
id: number,
name: string

constructor (id: number, name: string){}
}

class Employee extends Person {
position: string

constructor(id: number, name: string, position: string) {
super(id, name)
this.position  = position
}
}


-----------------------typecasting with <>

let x : unknown = "hello"  
console.log((<string>x).length)  or console.log((x as string).length); // this won't change type of data within variable. 

-----------------------GENERICS - FOR TYPECASTING A FUNCTION --- dynamically typecast.. work with any data type. 

function getArray(items : any[]): any[] {
return new Array().concat(items)
}

let numArray = getArray([1,2,3,4,5])
let strArray = getArray(["hello","snsns"]) 	// IT WILL ALSO ACCEPT THIS AS WE ARE ACCEPTING ANY ARRAY. 

strArray.push(6,7) // SAME GOES FOR THIS.

FOR TYPECASTING,  

function getArray<T>(items : T[]): T[] {
return new Array().concat(items)
}

let numArray = getArray<number>([1,2,3,4,5]) // THIS WILL PASS NUMBER AS T AND WILL MAINTAIN THIS DATATYPE FOR NUMARRAY. 
let strArray = getArray<string>(["hello","snsns"]) 	// THIS WILL PASS STRING AS T AND WILL MAINTAIN THIS DATATYPE FOR strArray.

strArray.push(6,7) // WILL GIVE ERROR AS WE ARE PASSING STRING AS THE TYPECASTING VARIABLE. 

FOR GENERATING REACT JS PROJECT FOR TYPESCRIPT - npx create-react-app . --template typescript 

UTILITY TYPES - 
Partial - changes all properties in an object to be optional.
Required - changes all properties to be required. 
Record - shortcut to defining an object type with specific jet type and value type. 
Omit - removes keys from an object type. 
Pick - removes all but specified keys from an object. 
Exclude - removes types from a union. 
ReturnType - extracts return type of a function. 
Parameter - extracts the parameter types of function as an array. 

----------------------INTERFACES - TO ASSIGN TYPES TO AN OBJECT.
interface is implemented by a class. 
interface Point {
x:number
y: number
z: number
}

let pointPart: Partial<Point> = {}  // Partial allows x and y to be optional
let pointPart: Required<Point> = {}  

const nameAgeMay: Record<string, number> = { 'Alice': 21, 'Bob':24 }

const pointPart1 : Omit<Point, 'x' | 'Y'> = { z : 23} // Omit has removed x and y and they can't be defined there. 

const pointPart1 : Pick<Point, 'x'> = { x : 23} // Pick has onlyed picked  x and other props were removed.

Exclude - 
type Primitive : string | number | boolean
const pointPart1 : Exclude<Primitive, string> = true // a string cannot be used here. since exclude has removed from here. 

type PointGenerator = () =>  { x: number, y: number}
const point: ReturnType<PointGenerator> = {
	x:7,
	y: 10
}

Parameters - 
type PointPrinter = (p: { x: number; y: number; }) => void;
const point: Parameters<PointPrinter>[0] = {
  x: 10,
  y: 20
};


---------------------------TYPES --------------------------------------
similar to interfaces but advanced can aggregate data two types together. 

Union --- |  ---  string | number

Intersection --    Employee & manager  // combination of type employee and manager. 


---------------------------tsconfig.json ------- config file used for changing compilation process---------

1. target : specifies ecmascript version in which file will be compile the typescript code. 
	es5, es2020 --- es5 will have function keyword. es2020 will have arrow function. 
	
2. rootDir : compiler will look for .ts files to compile. 

3. outDir - compiler will output .js files in this directory.

4. noImplicitAny : true // will have to do explicitly assign type

5. removeComments : whether to include in final js. 

---------------------------ENUMS----------------------
	define set of named constants. 
		enum Direction {
			Up, Down, Right, Left  // will be assigned 0,1,2,3 by default .  
		}
		// to access  Direction.Up. 
		

------------------------Pick--------------------------------
allows us to pick new type by selecting a set of properties from an existing type. 

interface User {
	id:number;
	name: string;
	email: string;
	createdAt: Date;
	}
	
type UserProfile = Pick<User, 'name' | 'email'>    // only pick name and email types...

const displayUserProfile = (UserDet : UserProfile) => {}

------------------------Partial----------------------------
makes all the properties in a type optional. 

type UserProfile = Pick<User, 'name' | 'email'> 

const displayUserProfile = (UserDet : Partial<UserProfile>) => {}  // all properties are now optional.

------------------------ReadOnly---------------------------
When we have some config details that shouldn't be altered after initialization making it readonly.

interface Config = {
	readonly apiKey: String;
	readonly url: String;
	}

const configVariables :  Readonly<Config> = {
		apiKey: "82388338",
		url: "https://g.com"
	}	


---------------------Record and Map--------------------
cleaner way to give types to objects. 

interface User {
	name: string;
	age: number
	}

Instead of doing , type Users: { [key: String]: User } = {
						"userid" : {
							name:"saurbah",
							age: 18
							}
					}
 can use Record to do this, 
			type Users: Record<String, User>  = {
						"userid" : {
							name:"saurbah",
							age: 18
							}
					}
Map can give fancier way to deal with objects. 
			const usersMap = new Map<string, Users>()
	UsersMap.set("userId", {name:"Gaurav", age:20})		
					
--------------------Exclude-----------------------------
When you want to have multiple types, but want to exclude few types.. 
type Event = 'click' | 'scroll' | 'mousemove'
type ExcludeEvent = Exclude<Event, 'scroll'>  // can assign this type it will exclude scroll and will take type of click and mousemove.

--------------------


