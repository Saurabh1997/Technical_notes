----------REACT BASICS 
vscode generates something called as emmet to generate code. 

document.createElement to create element and document.appendChild(toRootElementSelected)
--- All this document methods are inside JS engine by browser.

crossorigin in script tag - to change mode of request to an HTTP CORS Request. to allow resources on a webpage to be requested from another domain..  

shortcut - rafce - generate template to create functional component. 

CORS - MECHANISM that uses additional http headers which tells browser if a webapp can share resources with other web app.both webapp should have different origins. 
Before making any api call, browser itself will call a CORS preflight/(also known as OPTIONS request) call to the other origin resource. if call is valid, other origin resource will send additional http headers which will let the browser know that it can proceed with its normal API call
	OPTIONS REQUEST USING 3 http request headers.
	additional headers - Accept-Control-Allow-Origin:* , Accept-Control-Allow-Methods (put,post methods to be allowed), Origin:
	SOLUTION : to Solve this error, send this header from server. 

REACT CAN BE USED THROUGH CDN LINKS. BUT THE NETWORK CALL FOR REACT CAN BE HEAVY SO ITS NO RECOMMENDED. 

React.createElement(htmlTag, attributeToPass, ChildrenElement) - to create ReactElementObject
ReactDOM.createRoot(container) = to create root DOM element and it returns React DOM object which will then convert into HTML DOM element while we use render method. 
 
React.createElement(htmlTag, attributeToPass, [React.createElement(html, attributeToPass, element)]) - to make multiple siblings we can pass third argument as an array of react objects elements. 
This is the reason we use JSX because using this methods to create nested elements is complex. 

WHY REACT COMPONENT ONLY RETURNS ONE SIBLING - why not two div sibling because it create confusion for the reconciliation. virtual DOM DIFFING works more efficiently when it can compare a single tree structure. 	

NOTE: REACT ELEMENT IS NOT AN HTML OR DOM ELEMENT. REACT ELEMENT IS AN OBJECT. WHEN WE RENDER IT INTO DOM, THEN IT BECOMES HTMLELEMENT.

NOTE: ORDER OF SCRIPT TAGS AND FILES IMPORTED MATTERS.
We can use React for just a section of the web page...only for a footer we can use React. below root and above root, we can use normal html tags. 
React is a library.. we can plugin react anywhere. 

npm -- is not node package manager. it doesn't have a full form. its just a package manager. 
package.json - npm configuration. 
package-lock.json - locks the version. keeps record of every exact version of dependencies. 
				also contains integrity - hash..whatever is in my local its the same in production. keeps track of all versions. 
				node_modules - fetches all code of dependencies into our system
	transitive dependencies - a node module can have dependencies and those dependencies can have their own dependencies. every node module will have own dependencies in package.json its imp to put both package.json and package-lock in git. 

bundler - to bundle our app to push it to production. 
create-react-app uses webpack and babel behind the scenes to bundle our app. 
2 types of dependencies () - devDependencies - required for development and normal dependencies - used in production. 

parcel - 
npm i -D parcel. 
npx parcel entry file  // npx is executing package. 
 
 -- PARCEL - 
	dev build, set up a local server
	HMR - hot module replacement - allows all modules to be updated at runtime without needing for a full refresh. 
	- it uses file watcher algorithm which is written in C++. 
	- gives faster builds using caching. Reliable caching, 
	- will also do image optimization. 
	- minification of file for production. bundling and compression. 
	- content-hashing - keeps track of all file. includes content hashes of all output files for browser caching. when content of bundle changes, hash included will be updated.  
	- code splitting to split files. 
	- differential bundling - to support old browsers. 
	- diagnostics 
	- for better error handling 
	- HTTPs support. parcel file --https can run in https. 
	Parcel is designed around a multi-core architecture that parallelizes work across all cores. 
	- lazy dev builds. in development can put off building files until requested in browser.
	- tree shaking - supports ES and commonJS out of box, analyzes imports and exports and removes them if not used. unused CSS classes can be removed. 
		it will remove unused code by tree shaking algorithm.
	- it has different build bundle for dev and production. 

npx parcel build App.js --- to build production ready build.  which will be faster and more optimized. 
npx parcel index.html -- dev build. 

it builds all files into folder dist and uses .parcel-cache to keep track of what files are changing. 

browserslist - npm package to tell what all browsers should your app support. 
	we put browserslist in package.json 
	browserslist: [
	"last 2 Chrome version",	
	]    // 
	
	or we can do 
	browserslist: {
	"production": [
	],
	"development": []
	}

can configure seperately for countries.  cover 99.5% in US. 

CRA - create-react-app uses babel and webpack under the hood of react-scripts. 
	packages that come under CRA - 
	Babel - transforms higher ES6 to older version(ES5) and add polyfills - code that implements missing feature in browser. 
			babel is used to transpile(tranforms) jsx code to react.createElement object. 
	ESLint - JS linter to scan code and flag console warnings. 
	Jest - to write test scripts.
	PostCSS - to transform css to lint CSS.
	CSS loader & style loader - css-loader to help webpack collect css and put into <style>
	Webpack - module bundler that puts everything together
		
	JSX - JSX is different. react is different. is not react and is not included in react. its makes easy for react deevloper. its a combination of html and js. this is not HTML inside javascript. 
			HTML like or XML like syntax . jSX is just a syntax. 
----NOTE: JSX Code is transpiled to React.CreateElement (makes a JS Object)object (JSX => REACTELEMENT (JS Object) object) and then its rendered into browser as HTMLELEMENT
------Babel is transpiling jsx code to react.createElement object which can be rendered as htmlElement. it basically read one by one character. 
		babel create an AST.. abstract syntax tree to read character one by one.
	
	React functional component - is just a function that will return JSX component. it should always start with capital letter. 
		React Functional component is a normal js function which returns a react element (JSX Element). 
to render functional component,   <></>.. and to render normal react element, we directly call it like a function.. react.render(header)
TO RENDER NORMAL REACT ELEMENT,  INSIDE JSX,    {headerElement}
---PROPS -- We pass props just as we pass an argument to a function. 
	
	Component composition - nested components ..for passing component as a prop to other components. 
	JSX automatically sanitizes and parses the code.. if any MALICIOUS CODE comes from backend. it prevents cross site scripting attacks.
	
	Instead <Component/>, we can also call functional component inside jsx as we call normal functions. for e.g,     {Component()}
	React Fragment behaves like an empty tag. <> is shorthand for react Fragment. 
	
---React HOOK - normal JS utility function given by react. 
-----useState - supervariable. UI layer is always in sync with the data layer (which is state variable). whenever state variable updates, react rerenders the component. 
	we use const [variable, setVariable] = useState.. how react is able to change a const variable. actually react is rerendering..the component.. so at the time of initialization of rerender, we are setting new value.
Hooks can only be called inside function or body of a function. 	

2 process happen in react - reconciliation - to compute which parts of tree are changed.
rendering - renderer uses the infromation returned by reconciler to actually update the rendered app. 
Both happen in seperate process. THIS SEPERATION MEANS SAME RECONCILER CAN BE USED BY REACT AND REACT NATIVE AND CAN USE DIFFERENT RENDERERS. 

React uses RECONCILIATION algorithm (also known as React FIBER - REACT 16)- 
Reconciliation is A PROCESS OF ensuring HOW VIRTUAL DOM WILL BE REFLECTED INTO THE ACTUAL DOM. React compares new virtual DOM with the previous DOM and determines min no of operations needed to make the update in actual dom.  

React creates virtual dom. virtual dom is representation of actual dom (object representation of actual dom). 
Virtual dom is nothing but a normal js object (React element). 
Whatever changes we are doing that are reflected in the virtual dom.. For example - if we filter the list when clicked on button
	
DIFF ALGORITHM - diffing is core part of reconciliation. comparison process is called diffing. 
it finds the difference between previous and new virtual dom to identify the differences then updates that particular dom. it finds the difference between two objects which is faster than finding difference between two HTML elements. 
React implements a heuristic O(n) algorithm based on few assumptions: 
		1.  2 elements of diff type will have 2 diff tree. 
		2. 	Developer can tell which child element maybe stable due to different key prop. 
	When comparing elements of same type, React will only update the attributes which are changed. 	
	Heuristic algo is used to efficiently determine min set of changes required to update the DOM. 
Note: updation at end of node will hve good performance over updation at beginning.. in a list. but react works with keys (different key)
OBSERVATION : Using indexes as key can cause issues with states if we are doing reordering.. If key is an index, moving an item changes the key only.. 
NOTE: Rerender doesn't mean component will unmount and mount again.. it will only apply the differences following the diffing algorthm. 

Keys should be stable, predicatable and not Using Math.random() as it will cause many instances unneccessary render AND CAN CAUSE PERFORMANCE DEGRADATION AND LOST STATE in child components.. 

WHY KEY IS IMPORTANT : to uniquely identify an element within the list of elements.. its used to prevent rerendering of list of elements. so that react will know which key number of element to update.. 
NOTE:   	Never use index AS A KEY. its an anti-pattern. coz index might cause issue with rerendering when index is reordered. IF WE ADD OR DELETE ELEMENT OR REORDER THE ELEMENT, INDEX WILL CHANGE AS PER .MAP DYNAMICALLY WHICH CAN CAUSE EXTRA RERENDERING. 

COMPOSITION - Components written by diff people can work together., 

---REFS - When we want to remember some information or connect to external system but don't want that info to trigger rerender, we use Ref. Refs are retained between rerenders.. changing ref doesn't rerender.  
		
--REACT DOES EFFICIENT DOM MANIPULATION. 
	[variable, setVariabl] = useState is array destructuring. 
	Whenever we call setVariable, it rerenders the component.

------------------------SEPERATION OF CONCERN--
for each and every thing, a seperate project folder. this is also single responsibility principle. 	
	
CURRYING IN REACTJS - 
instead of having different handle change for each input text.. can 
	use : input onChange={handleChange(setName)}
		  input onChange={handleChange(setEmail)}	
		  input onChange={handleChange(setPassword)}
	const handleChange = (setState) => (event) => setState(event.target.value)	  
	
-----------------onCLick={handleClick()} vs onClick={() => handleclick()} vs onClick={handleClick}------------------
onCLick={handleClick()} -- this will call the function rightaway but we want it to be called on click.. so we have to pass callback function. 
onClick={handleClick} -- this returns the function instance so it will be called on click.  
	
	
CONFLICT DRIVEN UI - UI DRIVEN BY DATA or conflict. as per the location, restaurants speciality might change.. we might not have a speciality to display so that component shouldn't render in that location. 

FILE STRUCTURE: THERE IS NO SPECIFIC FILE STRUCTURE RECOMMENDED BY REACT DOCS. 
file extensions doesn't matter. can write .js, .jsx or .ts, .tsx.

CORS - Browser block us to call api from one origin to different origin.. (from localhost).Security mechanism check
	1. Before making an api call, browser makes PREFLIGHT OPTIONS CALL TO THE SERVER TO CHECK IF THE CALL IS VALID.. THEN SERVER WILL SEND ADDITIONAL HTTP HEADERS to the Browser to let it know that it is valid. 
	2. Then actual api call will happen. 
		ADDITIONAL HTTP HEADERS - 
			ACCEPT-CONTROL-ALLOW-ORIGIN : * // means all domains outside of this are allowed to make request to this.
						 -ALLOW-METHODS:POST, GET  // methods allowed to call from the domain. 
	We can set the headers in server. also can use chrome extension. 
	
SHIMMER UI effect - RESEMBLES ACTUAL PAGE'S UI TO SHOW USERS HOW QUICKLY IT WILL LOAD THE PAGE. 

---------------React-Router-DOM--------------------------------
react-router - BrowserRouter to declare individual routes. needs to be wrapped around entire application tree. 
LIMITATIONS - cannot access history data outside of router. cannot create a Route outside BrowserRouter.
need atleast 2 props - path and component reference to render. 
	NOTE: IF WANT A COMPONENT TO BE VISIBLE ON EVERY PAGE, PUT INSIDE BrowserRouter BUT ABOVE DECLARED ROUTES. 
	
SWITCH - MULTIPLE ROUTES WITH DIFFERENT PATHS BUT SAME PAGE. can have "/" and "/about" as routes and use <Route exact path ="/" component ={HOME}/>
looks through all child routes and displays first one whose path matches the current URL.

// TO CATCH ALL ROUTE (AS IN 404 ROUTE - IF NOT AVAILABLE)        <Route path="*" component={NotFound} />
 
LINK - can create links using <Link to = "/About"></Link>

NOTE : For linking routes, Never use <a href> because it just reloads the page. 
Instead use, 
<link to="/route"> </Link>
-----INTERNAL IMPLEMENTATION OF LINK - it has href only. link is a wrapper over href. 	

REDIRECT - Redirect to another component if login is succesful. <Route render= {(props) => isAuth()? <component> {...props}  : <Redirect to = "/">}>

useHistory hook - get history data. history.location data. to navigate user programmatically 

using useHistory(), can navigate using history.push('/path').
--------------to show common components such as header and footer in all pages. we use "children" property and "Outlet" component returned by react-router-dom.
then in main <Component>, 
<header><Outlet/> // returned by react-router-dom
Outlet is like a tunnel through which children component goes through and gets rendered instead of Outlet. 

const AppRouter = createBrowserRouter([
  {
    path: "/",
    element: <App />,			// main component where common components and outlet is going to be rendered.
    errorElement: <ErrorPage />, // works like ErrorBoundary.
    children: [
      {
        path: "/",
        element: <CalcView />,	// child component you want to render in outlet's place. 
      },
      {
        path: "/about",
        element: <About />,		// component you want to render in outlet's place. 
      },
      {
        path: "/signup",
        element: <Signup />,
      },
	  {
        path: "/restaurants/:resId",
        element: <Signup />,
      }
    ],
  },
]);

// TO use the router : 
<RouterProvider router={router}> // wrap entire app component in this. 

// DOUBT - USING REACT ROUTER V6 WITH REDUX 

NOTE: useRouteError() hook can be used to return any error thrown during any action, loading ot if user navigates to a page whivh doesn't exist. 
this is directly given by react-router-dom.
const err = useRouteError() ..  // in error routing component.  
								/// use this error to show specific msg  - err.status
REACT IS USED TO BUILD SPA. because all components are rendered in one page only. 

two types of routing is there : 
1. server side routing - we request server everytime we want to go to a certain path. using anchor tag. we make a network call. new page comes from server.
2. client side routing - we don't make network calls. all the components have already come to the client. it just manipulates and renders the component. 

      <CalcView></CalcView>

to get the :resId, we use "useParams" hook from react-router-dom.
const {resId} = useParams()

-------------------- Class based component -- 
if there is one parent comp and 2 child comp inside it. 
	1. parent constructor, parent render is called. 
	2. child 1 constructor, render and then child 2 constructor, render
	3. child 1 component did mount, child 2 component did mount. 
	4. parent component did mount will be called at last. 
	it batches render phase for all child component. React batches the render phase. can make componentDidMount async. 
	can make call debugger using debugger;
if updation of state happens, then render will be called and then componentDidUpdate. 

componentWillMount - we have to clear intervals here if we have any. 	

--- Custom hook - can define own hooks. can define our own function. 
for example can be used for fetching data  or tracking if the friend is online or not. 

for defining custom hook, 
const useIsUserActive = (userId) => {
const [userValue, setUserValue] = useState()

useEffect(() => {
	// do something to get user status - can call api
	setUserValue(responseFromAPI)
}, [userId])}
return userValue
}

in main component, import the hook and can use the hook in all components. 
const isUserActive = useIsUserActive(userId) 

--------------------DIFFERENCE BETWEEN REACT.MEMO AND USEMEMO
------------------React.memo -  Higher order component used for optimizing functional components. 
wrap the component inside React.memo to avoid rerendering. If a parent rerenders, child also rerenders unless we use react.memo.  If we use React.memo for the child, when parent rerenders if anything changes in parent, child won't rerender. 
	for example - const app = React.Memo(({prop1, prop2}) => {}).

--UseMemo - to memoize the result of a function. it takes a function and array of dependencies and it returns the memoized result. 
	const value = useMemo(() => {}, [prop1, prop2])
to memoize the computation result for any expensive task	
	
----useCallback-------
to Memoize functions which is passed to child components which rely on reference equality to prevent unneccessary rerender. 
if we define any function and then pass it on child component, child component will rerender when parent rerenders even if function passed to child is constant unless we wrap that in useCallback.

const func = useCallback(() => {console.log(" rerendered ")})
<child func = {func}>.
Now when anything changes in parent. function is the same, so child won't rerender. 

---Wrapper component---
inside container component we put child elements enclosed by container elements. 
<container>
<Child/>
<Child/>
<container/>

then to render the childs in container file when we want to render, then we will access child components using,
{children}  props. the components wrapped in container automatically comes in children prop. 
const container = ({children}) => {}

Optimization techniques in react - 
Memoization - react.memo , useMemo, useCallback 
Code splitting  - lazy loading, chunking, dynamic bundling,on demand loading, dynamic import - all the same 
------NOTE : All ABOVE ARE SAME AS CODE SPLITTING. SPLITTING LARGE BUNDLE OF REACT APP INTO CHUNKS TO LOAD FASTER..AND IN CHUNKS. 
-----WHENEVER LOADING THE APPLICATION, APP IS BUNDLED INTO A BIG SINGLE JS FILE WHICH IS A BIT HEAVY. 

If we have a seperate entities in our application, we can divide them into chunks of seperate modules.
for example, amazon will have product catelog components which can fit into one chunk, cart into one chunk, 
mini tv of amazon into one chunk. 

can import those chunks using Lazy loading. when go to that module, then only it should load.
but it SUSPENDS the LOADING OF THAT COMPONENT till we get the JS chunk for that component WHENEVER CALLED. 
MIDDLE STATE IS THERE WHERE WE WAIT FOR THE JS CHUNK CALL RESPONSE..
--To implement this, don't normally import, 
	const Grocery = lazy(() => import("./components/file.jsx"))
	
	WRAP Grocery component inside Suspense and give a fallback UI loader when component is not rendered. 
	<Suspense fallback={<h1>Loading<h1/>}> <Grocery/><Suspense/>
 
-------WAYS OF writing css
1. using Sass and SCSS.
2. styled components - usually used.

------------HIGHER ORDER COMPONENT-------------
its a functional component which takes in a component enhances it and returns the enhanced component. 
define a component which takes a component as  prop and this component enhances and returns the enhanced component. 

------------Lifting the state up-----------
if two sibling components are having some states which they have to share collectively.. we can lift the state up by moving the state to their closest parent and then pass it down as props. 
for example - metrics accordian.  if we want to close all other accordions, when any of them is opened. 
--NOTE-- Always push the props as low as possible to avoid rerender of unneccessary components

---------------Props drilling----------------------
passing props into nested child components. means syntactic uneasiness of code. problem of passing props.
causes rerender and doesn't look good. 

------------to avoid props drilling-----CONTEXT API----------
Context is a global level storage which can be provided to the whole app. 
	const userContext = createContext({
	userName: "",
	setUserName: ()=> {}
	})
 wherever we want to use just do const {userName, setUserName} = useContext(userContext)

IN CLASS BASED COMPONENT- <UserContext.Consumer> {(data)=>{data.loggedInUser}}

for FUNCTIONAL BASED -- to update the state as well. 
<UserContext.Provider value={{userName: user, setUserName: setFunctionToBeSupplied}}>   value= {{}} // if multiple key values in an object.
--DISADVANTAGES OF USING CONTEXT -- 
	rerender happens when nested components context value changes changes. this context api is just to do syntactically better and cleaner prop drilling. 

-------------RECOIL REACT-----------------------------------
its made on top of context api. 
ATOM - smallest unit of state. its for storing state. can be defined outside of any component. can be teleported to any component. similar to how we useState. 
	export const userAtom = atom({
	key:"userAtom",
	default:"defaultValue"
	})

5 concepts in Recoil --
1. useRecoilState - works like useState. gives two variables in an array - variable name and a function to update value. 
2. useRecoilValue - only gives value. 
3. useSetRecoilState - gives a function to update value. 
4. RecoilRoot - whichever component is using recoil has to be wrapped inside RecoilRoot tag. 
5. ----SELECTORS ------
	represents a derived piece of state. it derives its meaning from the atom state. 
	Derived state lets us build dynamic data which depends on one or more atom states. can define selector in same atom file. no need of memoizing the atom state. 
 const evenSelector = Selector({
 key:"evenSelector",
 get: ({get}) => { return get(userAtom) %2 ===0 }
 })
  // to use this Selector, can do --- const isEven = useRecoilValue(evenSelector)

////// HERE evenSelector is dependent on the userAtom. can useRecoilValue on userAtom but it won't be optimal solution as it will rerender everytime useRecoilValue is updated.. 

----EXAMPLE 2 TO USE Selector --
	suppose we have to filter input text.. where we have to show whatever filter list in the dropdown.  instead of applying filter to the useState everytime user is typing in the filter. 
	We can have two atom states - one for the original array and other for the filter which has to be used to filter the array. 
	SOLUTION: now for the filtered array,  WE WILL WRITE A SELECTOR. 
		const FilteredSelector = selector({
		key: "filteredSelector",
		get: (props) => {
			props.get(originalAtom).filter((element) => element.includes(props.get(filtered)))
			}
		})
	NOTES: RECOIL PROVIDES A WAY TO MAP STATE & DERIVED STATE TO COMPONENTS VIA FLOW DATA GRAPH. Recoil can mix synchronous and asynchronous functions in data flow graphs of Selectors. 
	
----Asynchronous Data Queries in recoil-------
cannot do async API calls in Selectors directly. but can pass Selector as default of atoms  and can call async calls in get function. 
export const getUserAPIResponse = atom({
	key:"userData",
	default: selector({
		key:"userDataSelector",
		get: async ({get}) => {
			const res = await axios.get("url")
			return res.data;
			},
		set?: ({set, get}, newValue) => {
			// this is usually used to set the original atom state..from where we are deriving the value for //this selector. 
			// new value = what did the user passed in the setState function returned by useSetRecoilState. 
			set(atomVariable, newValue) 	// to set the value of atom. 
		}
		})
	})
	
// NOTE: IF WE WANT TO USE SET FUNCTION OF THE SELECTOR, WE USE const [data, setData] = UseRecoilState(selectorName).
then where we want to do set value, we just use the "setData" function..
	
----AtomFamily------
	LETS US DYNAMICALLY CREATE ATOMS. RETURNS A WRITABLE RECOILSTATE ATOM.
-basic - used to create family of atoms, each with unique key. If we have a list of items and each item needs its own recoil state. 
	if we need a different atom per component, we can use AtomFamily. there are 3 components but they should be supplied a different atom. 
	AtomFamily - if a component needs a new atom specific to an input from component.. it will give the input and atomFamily will return dynamic atom. In this case, components will subscribe to the atomFamily. 
	based on the id of the component, that particular atom id component will be rendered..
	Example.. for lot of todos in a todo app, every todo will have different atom. Every atom in atomFamily will have unique key.. id. 
		export const todoAtomFamily = atomFamily({
				key:"todoAtomFamily",
				default: id  => { return TODOS.find(x => x.id === id)} // to find that specific id atom. 
			})
	TO USE THIS ATOM FAMILY ---
		const atomValue = useRecoilValue(todoAtomFamily(id))
		const updateAtomValue = useRecoilState(todoAtomFamily(id)) -- to update that particular id atom.
--DOWNSIDE IF WE USE A GLOBAL ARRAY IN A SINGLE ATOM AND THEN SUPPLY FROM THAT ARRAY ELEMENT TO THE COMPONENT.. IF ONE OF THE ELEMENT CHANGES ALL COMPONENTS WILL RERENDER AS WE HAVE ONE SINGLE ATOM TO STORE ALL ELEMENTS. 
THAT'S WHY WE NEED SEPERATE ATOM FOR EACH ELEMENT AND AtomFamily can have different atoms for each component. 

----SelectorFamily--- asynchronous data query in atomFamily. used to create family of selectors in a more dynamic way. 
	returns a read only RecoilValueReadOnly or writable RecoilState selector. used to do asynchronous API for atomFamily - if you need to hit API for each component atom.. 
	Definition: SelectorFamily() utility returns a function which can be called with user defined parameters & returns a selector. each unique parameter will return same memoized selector instance.. 
	NOTE::: WHENEVER USING AN ATOMFAMILY, ALWAYS USE A SELECTORFAMILY TO GET DIFFERENT SELECTOR PER DIFFERENT ATOM.  
	export const todoAtomFamily = atomFamily({
				key:"todoAtomFamily",
				default: selector({
					key:"todoSelector",
					get: (id) => async ({get}) => {
						const res = await axios.get(url+id)	// api call for id based. 
						return res.data.todo
					}				
			})

---useRecoilStateLoadable--- what happens if API call takes a long time, we see blank screen initially. 
Instead of useRecoilState, can do [todo, setTodo] = useRecoilStateLoadable(atomFamily(id))
	// todo will return an object with {state, content} .. // state will have "loading", "hasValue", "hasError".
	we can do  if(todo.state === "loading") {  return "Loading..."}
			else if(todo.state === "has value") {return with todo.content.propertyName}
	
	// APPLICATION CAN CRASH IF BACKEND FAILS.
---useRecoilValueLoadable---if we want only value, can use this. 
	
-----FOR SMALLER TO MEDIUM - CAN USE CONTEXT OR RECOIL. 
-----REDUX IS MORE SCALABLE. it offers redux thunk. FOR BIGGER APPLICATION FOR DATA INTENSIVE APPLICATIONS. HEAVY READ AND WRITE OPERATIONS BETWEEN COMPONENTS. managing store
----- ZUSTAND IS ANOTHER LIBRARY LIKE REDUX. 

------------------------REDUX TOOLKIT----------------------------------RTK----------
2 libraries - React-redux and redux-toolkit. Redux toolkit is the standard way to write redux. 
 3 problems with normal redux - 
	1. Configuring redux is complicated. has a learning curve.
	2. had to add lot of packages to make it useful.
	3. had to make lot of boiler plate code .. action creators, reducers, dispatching actions. 

1. We have centralized store called as redux store and then we have small part/pieces of the redux store which is called SLICES. 
2. to keep data part seperately - different object, we create different slices for example, userSlice, cardSlice to handle data of user and card. 

	when we click on add button, it dispatches an action which will call a function which modifies the cart. 	
	this function is called a reducer. 
	DISPATCHES ACTION -----> REDUCER ---> MODIFIES THE SLICE OF REDUX STORE
SELECTOR - WE USE SELECTOR TO READ THE DATA FROM SLICE. subscribes to the store. 
mapStateToProps - used when we want to subscribe to data from store.. useSelector
mapDispatchToProps - used when we want to update data in store. useDispatch. 

Reducer - responsible for updating the slices of redux store. 
Selector - to Subscribe to the store. const cart = useSelector((store) => store.cart.items) // DONT USE  useSelector((store) => store) 
ALWAYS SUBSCRIBE TO THAT PARTICULAR PIECE OF CODE... NOT ENTIRE STORE... AS IT MAKES APPLICATION LESS PERFORMANT. 

1. Build our store.
2. Connect our app to our store. 
3. create slices.
4. Dispatch action. dispatch(action). 
5. Selector.  

configureStore comes from reduxtoolkit. because configuring redux is redux job.
Provider comes from react-redux. providing store to react is react's job. 

const UserSlice = createSlice({
  name: "user",
  initialState: {
    userName: "",
  },
  reducers: {
    updateUser: (state, action) => {
      state.userName = action.payload;
	  state.cart.push(action.payload)
    },
    removeUser: (state, action) => {
      state.userName = "";
	  state.cart.length = 0  // this will actually work instead of state.cart = []
				// state.cart will modify local state but not original state.  			
				// or we can do 
	return { cart: [] }
    },
  },
});

export const { updateUser, removeUser } = UserSlice.actions;

export default UserSlice.reducers;

NOTE: EARLIER IT WAS NOT ALLOWED TO MUTATE THE REDUX STORE STATE.. 
BUT NOW WITH REDUX TOOLKIT, ITS RECOMMENDED TO EITHER MUTATE THE STATE OR RETURN A NEW STATE. 
REDUX TOOLKIT USES IMMER LIBRARY TO MUTATE THE STATE.. 
	
-- TODO---  why vite create-react-app
performance - form library -formik, react hook form for form management, REACT QUERY, SWR



----------------TIPS----------------------------

1. Whenever there are lot of providers for a client side app, its a good practice to wrap all providers in a Single Providers component, where we can wrap children element(actual main app) inside all Providers such as context provider, recoil 